\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

\section{A Toy Example}
In this section, we define a simple objective function called $eval()$ which calculates the sum of a penalty term and the squared error between the DataRemix reconstruction and the original input matrix. The input matrix is a 100-by-9 matrix with random values. In this case, we know that when k=9,p=1 or $\mu=1$, p=1, DataRemix reconstruction is the same as the orginial matrix and the objective function achieves the minimal value which is qual to the penalty term we add. 
<<echo=TRUE>>=
library(DataRemix)
eval <- function(X_reconstruct, X, penalty){
  return(-sum((X-X_reconstruct)^2)+penalty)
}#eval
@
First we genrate a random matrix with dimension 100-by-9 and perform the SVD decomposition.
<<echo=TRUE>>=
set.seed(1)
num_of_row <- 100
num_of_col <- 9
X <- matrix(rnorm(num_of_row*num_of_col), nrow = num_of_row, ncol = num_of_col)
svdres <- svd(X)
@
Set mt to be 2000.
<<echo=TRUE>>=
basis_short <- omega[1:2000,]
@
Infer the optimal combinations of k, p and $\mu$. Here $X$ and $penalty$ are additional inputs for the $eval()$ function.
<<echo=TRUE>>=
DataRemix.res <- DataRemix(svdres, eval, k_limits = c(1, length(svdres$d)), 
                 p_limits = c(-1,1), mu_limits = c(1e-12,1), 
                 num_of_initialization = 5, num_of_thompson = 50, 
                 basis = basis_short, xi = 0.1, full = T, verbose = F, 
                 X = X, penalty = 100)
knitr::kable(cbind(1:55,DataRemix.res$para), align = "l", 
             col.names = c("Iteration","k","p","mu","Eval"))
@
\section{GTex Correlation Network}
In this section, we define a different task of optimizing the known pathway recovery based on the GTex gene expression data. $corMatToAUC()$ is the main objective function with two inputs: $data$ and $GS$. We formally define the objective as the average AUC across pathways and we also keep track of the average AUPR value. You can refer to the $corMatToAUC()$ document for more information.
<<echo=TRUE>>=
library(DataRemix)
@
Load the data. $GTex\_cc$ stands for the GTex gene correlation matrix with dimension 7294-by-7294 and $canonical$ represents the canonical mSigDB pathways with dimension 7294-by-1330. It takes time to decompose $GTex\_cc$, thus we pre-compute the SVD decomposition of $GTex\_cc$ and load it as $GTex\_svdres$.
<<echo=TRUE>>=
load(url("https://www.dropbox.com/s/o949wkg76k0ccaw/GTex_cc.rdata?dl=1"))
load(url("https://www.dropbox.com/s/wsuze8w2rp0syqg/GTex_svdres.rdata?dl=1"))
load(url("https://github.com/wgmao/DataRemix/blob/master/inst/extdata/canonical.rdata?raw=true"))
#svdres <- svd(GTex_cc)
@
Run corMatToAUC() on the default correlation matrix $GTex\_cc$.
<<echo=TRUE>>=
GTex_default <- corMatToAUC(GTex_cc, canonical)
GTex_default
@
Set mt to be 2000.
<<echo=TRUE>>=
basis_short <- omega[1:2000,]
@
Infer the optimal combinations of k, p and $\mu$. Here $GS$ is the additional input for the $corMatToAUC()$ function.
<<echo=TRUE>>=
DataRemix.res <- DataRemix(GTex_svdres, corMatToAUC, 
                           k_limits = c(1, length(GTex_svdres$d)%/%2), 
                           p_limits = c(-1,1), mu_limits = c(1e-12,1), 
                           num_of_initialization = 5, num_of_thompson = 150, 
                           basis = basis_short, xi = 0.1, full = T, verbose = F, 
                           GS = canonical)
knitr::kable(cbind(1:15,DataRemix.res$full[order(DataRemix.res$para[,4],decreasing = T)
             [1:15],]), align = "l", col.names = c("Rank","k","p","mu",
             "mean AUPR", "mean AUC"))
@
\end{document}
